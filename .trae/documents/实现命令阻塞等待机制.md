# 实现命令阻塞等待机制

## 问题分析
当前实现中，对于长时间运行的命令（如REACTOR_SOLUTION_ADD、POST_PROCESS_SOLUTION_ADD等），系统会立即返回True，没有阻塞等待命令完成。但用户需要能够阻塞等待命令返回，才能执行下一步操作。

## 解决方案设计

### 1. 修改_send_command方法，添加阻塞等待参数
- 添加`blocking`参数，默认为False，表示非阻塞模式
- 当`blocking`为True时，阻塞等待命令完成
- 当`blocking`为False时，保持当前的异步模式

### 2. 实现阻塞等待机制
- 使用事件（Event）机制实现阻塞等待
- 注册任务并设置回调函数
- 当任务完成时，通过事件通知主线程
- 主线程等待事件触发后继续执行

### 3. 修改相关命令执行方法
- 为所有命令执行方法添加`blocking`参数
- 将`blocking`参数传递给`_send_command`方法

### 4. 核心代码修改

#### 4.1 修改 `_send_command` 方法
- 添加`blocking`参数，默认为False
- 实现阻塞等待逻辑
- 支持通过任务ID和事件机制等待命令完成

#### 4.2 修改相关命令方法
- 为`reactor_solution_add`、`post_process_solution_add`等方法添加`blocking`参数
- 将`blocking`参数传递给`_send_command`方法

#### 4.3 扩展任务管理功能
- 支持通过任务ID等待任务完成
- 添加任务完成事件机制

### 5. 具体实现步骤

1. **修改 `_send_command` 方法**：
   - 添加`blocking`参数
   - 实现阻塞等待逻辑
   - 使用事件机制等待任务完成

2. **修改命令执行方法**：
   - 为所有命令执行方法添加`blocking`参数
   - 将`blocking`参数传递给`_send_command`方法

3. **测试修改后的功能**：
   - 测试阻塞模式下的命令执行
   - 测试非阻塞模式下的命令执行
   - 确保两种模式都能正常工作

### 6. 预期效果
- 用户可以通过设置`blocking=True`来阻塞等待命令完成
- 用户可以通过设置`blocking=False`来保持当前的异步模式
- 命令执行方法的接口保持向后兼容

## 代码修改范围
- `_send_command`方法（行703-734）
- 所有命令执行方法，如`reactor_solution_add`、`post_process_solution_add`等
- 可能需要扩展任务管理功能，添加等待任务完成的方法

## 使用示例
```python
# 阻塞模式下执行命令
result = workstation.reactor_solution_add(solution_id=1, volume=100, reactor_id=1, blocking=True)
# 命令执行完成后才会执行下一步
print(f"命令执行结果: {result}")

# 非阻塞模式下执行命令（保持原有行为）
result = workstation.reactor_solution_add(solution_id=1, volume=100, reactor_id=1, blocking=False)
# 命令发送后立即返回，不等待执行完成
print(f"命令发送结果: {result}")
```